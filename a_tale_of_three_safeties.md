# 三种安全性

Midori 是在三种安全性的基础上建立的：类型、内存以及并发安全性。这些安全性排除了一整类的“建造” bug，而且在可靠性、安全性、开发人员生产力方面带来了巨大的提升。而且它们从基础上允许我们用一种新的更强有力的方式去依赖类型系统，去带来新的抽象，去完成新奇的编译器优化，还有更多。再回过头看，我们项目最大的贡献是证明了，整个操作系统和它的系统服务、应用和类库生态系统能全都用安全代码写出来，而且没有性能损失，在若干重要的维度还有一些数量级的领先。

首先，让我们定义这三种安全性，根据基础性来排序：

* [内存安全性](https://en.wikipedia.org/wiki/Memory_safety) 阻止访问内存的非法区域。若违反内存安全性，将出现多种缺陷，包括缓冲区溢出，释放 (free) 后使用内存，以及重复释放内存。总体来说，违反内存安全性是一种很严重的问题，会导致很多漏洞，譬如代码注入等。

* [类型安全性](https://en.wikipedia.org/wiki/Type_safety) 阻止使用分配给别的类型的内存。若违反类型安全性，将出现多种缺陷，包括类型混淆，转换错误，以及未初始化的变量。虽然通常没有违反内存安全那么严重，但违反类型安全性仍然会导致漏洞，特别是可能引发内存安全漏洞。

* [并发安全性](https://en.wikipedia.org/wiki/Thread_safety) 阻止不安全的并发使用共享内存。此类众所周知并发危害包括[数据冲突](https://en.wikipedia.org/wiki/Race_condition)，或读写、写读、写写危险。通常，如果违反了并发安全，会频繁导致类型、进一步导致内存安全性被违反。这种问题比较微妙 —— 像内存被撕裂一样 —— 我们经常说，并发漏洞是安全漏洞利用的“下一个前沿”。

目前已经存在很多方法来确保一项或多项以上安全性，并/或保护目标免于危害。

[软件故障隔离](http://www.cs.cmu.edu/~srini/15-829/readings/sfi.pdf) 建立内存安全防护罩避免最严重的漏洞。这会带来一些运行开销，虽然[自带证明代码](https://en.wikipedia.org/wiki/Proof-carrying_code)能够减轻这部分开销。这种技术没能给类型和并发安全提供什么好处。

另一方面，基于语言的安全性，是归纳地通过类型系统规则以及局部检测（相对于全局），保证某些操作不会发生，再加上可选的运行时检查（像在缺失更强的[依赖类型系统 (dependent type system) ](https://en.wikipedia.org/wiki/Dependent_type)中的数组边界检测）。这种方法的好处在于排除安全漏洞通常更有效，因为开发者在写代码的时候就能找到问题，而不是等到程序运行的时候。但如果你能欺骗类型系统允许执行非法的操作，你就完蛋了，因为就没有防备黑客突破内存安全性的防护罩了，他可以执行任何代码。

多种技术经常结合其他技术使用，称为深度防护，为了利用它们其中最好的部分。


