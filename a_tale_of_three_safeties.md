# 三种安全性

Midori 是在三种安全性的基础上建立的：类型、内存以及并发安全性。这些安全性排除了一整类的“建造” bug，而且在可靠性、安全性、开发人员生产力方面带来了巨大的提升。而且它们从基础上允许我们用一种新的更强有力的方式去依赖类型系统，去带来新的抽象，去完成新奇的编译器优化，还有更多。再回过头看，我们项目最大的贡献是证明了，整个操作系统和它的系统服务、应用和类库生态系统能全都用安全代码写出来，而且没有性能损失，在若干重要的维度还有一些数量级的领先。

首先，让我们定义这三种安全性，根据基础性来排序：

* [内存安全性](https://en.wikipedia.org/wiki/Memory_safety) 阻止访问内存的非法区域。若违反内存安全性，将出现多种缺陷，包括缓冲区溢出，释放 (free) 后使用内存，以及重复释放内存。总体来说，违反内存安全性是一种很严重的问题，会导致很多漏洞，譬如代码注入等。

* [类型安全性](https://en.wikipedia.org/wiki/Type_safety) 阻止使用分配给别的类型的内存。若违反类型安全性，将出现多种缺陷，包括类型混淆，转换错误，以及未初始化的变量。虽然通常没有违反内存安全那么严重，但违反类型安全性仍然会导致漏洞，特别是可能引发内存安全漏洞。

* [并发安全性](https://en.wikipedia.org/wiki/Thread_safety) 阻止不安全的并发使用共享内存。此类众所周知并发危害包括[数据冲突](https://en.wikipedia.org/wiki/Race_condition)，或读写、写读、写写危险。通常，如果违反了并发安全，会频繁导致类型、进一步导致内存安全性被违反。这种问题比较微妙 —— 像内存被撕裂一样 —— 我们经常说，并发漏洞是安全漏洞利用的“下一个前沿”。

目前已经存在很多方法来确保一项或多项以上安全性，并/或保护目标免于危害。

[软件故障隔离](http://www.cs.cmu.edu/~srini/15-829/readings/sfi.pdf) 建立内存安全防护罩避免最严重的漏洞。这会带来一些运行开销，虽然[自带证明代码](https://en.wikipedia.org/wiki/Proof-carrying_code)能够减轻这部分开销。这种技术没能给类型和并发安全提供什么好处。

另一方面，基于语言的安全性，是归纳地通过类型系统规则以及局部检测（相对于全局），保证某些操作不会发生，再加上可选的运行时检查（像在缺失更强的[依赖类型系统 (dependent type system) ](https://en.wikipedia.org/wiki/Dependent_type)中的数组边界检测）。这种方法的好处在于排除安全漏洞通常更有效，因为开发者在写代码的时候就能找到问题，而不是等到程序运行的时候。但如果你能欺骗类型系统允许执行非法的操作，你就完蛋了，因为就没有防备黑客突破内存安全性的防护罩了，他可以执行任何代码。

为了利用它们其中最好的部分，多种技术经常相互结合使用，称之为深度防护。

保证安全性的运行时方面的方法包括 [Google 的 C++ sanitizers](https://github.com/google/sanitizers) 和 [微软的 "/guard" 特性](http://blogs.msdn.com/b/vcblog/archive/2014/12/08/visual-studio-2015-preview-work-in-progress-security-feature.aspx)。语言方面的方法包括 C#、Java、绝大多数函数式语言、Go 等等。但我们已经发现一些攻击，因为 C# 有 unsafe 关键字允许违反安全性的 unsafe 区域。

那么，现在你要开发一个操作系统，主要任务是要控制硬件资源、缓冲区、服务和应用程序并行运行，诸如此类，所有的的这些都是该死的不安全 (unsafe) 的东西，你该如何使用安全的语言来搞定呢？好问题！

答案出乎意料的简单：分层。

系统里面当然有一些不安全的代码。每一个不安全的组件负责封装它们不安全的部分。说得容易做起来难，要搞对这些是系统里面最难的部分。这就是为什么我们要尽可能保持这个所谓的 [可信计算基](https://en.wikipedia.org/wiki/Trusted_computing_base) (TCB) 越小越好。在操作系统核心和运行时里没有东西使用不安全的代码，只有微内核里非常少的部分有使用它。是的，我们的操作系统调度器和内存管理器都是用安全代码编写的。所有的应用级程序和库都是 100% 的安全代码，就像我们整个 Web 浏览器一样。

依赖类型安全性的一个有趣的方面是[你的编译器](https://en.wikipedia.org/wiki/Bartok_(compiler))变成了你可信计算基 (TCB) 的一部分。虽然我们的编译器使用安全语言写的，但它生成供处理器执行的指令。这风险可以通过类似自带证明代码和[类型化汇编语言 (TAL)](https://en.wikipedia.org/wiki/Typed_assembly_language) 稍微补救一下。再加上运行时检查，如软件故障隔离等，也能减轻这种风险。

