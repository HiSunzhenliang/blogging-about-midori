# 三种安全性

Midori 是在三种安全性的基础上建立的：类型、内存以及并发安全性。这些安全性排除了一整类的“建造” bug，而且在可靠性、安全性、开发人员生产力方面带来了巨大的提升。而且它们从基础上允许我们用一种新的更强有力的方式去依赖类型系统，去带来新的抽象，去完成新奇的编译器优化，还有更多。再回过头看，我们项目最大的贡献是证明了，整个操作系统和它的系统服务、应用和类库生态系统能全都用安全代码写出来，而且没有性能损失，在若干重要的维度还有一些数量级的领先。

首先，让我们定义这三种安全性，根据基础性来排序：

* [内存安全性](https://en.wikipedia.org/wiki/Memory_safety) 阻止访问内存的非法区域。若违反内存安全性，将出现多种缺陷，包括缓冲区溢出，释放 (free) 后使用内存，以及重复释放内存。总体来说，违反内存安全性是一种很严重的问题，会导致很多漏洞，譬如代码注入等。

* [类型安全性](https://en.wikipedia.org/wiki/Type_safety) 阻止使用分配给别的类型的内存。若违反类型安全性，将出现多种缺陷，包括类型混淆，转换错误，以及未初始化的变量。虽然通常没有违反内存安全那么严重，但违反类型安全性仍然会导致漏洞，特别是可能引发内存安全漏洞。

* [并发安全性](https://en.wikipedia.org/wiki/Thread_safety) 阻止不安全的并发使用共享内存。此类众所周知并发危害包括[数据冲突](https://en.wikipedia.org/wiki/Race_condition)，或读写、写读、写写危险。通常，如果违反了并发安全，会频繁导致类型、进一步导致内存安全性被违反。这种问题比较微妙 —— 像内存被撕裂一样 —— 我们经常说，并发漏洞是安全漏洞利用的“下一个前沿”。

目前已经存在很多方法来确保一项或多项以上安全性，并/或保护目标免于危害。

[软件故障隔离](http://www.cs.cmu.edu/~srini/15-829/readings/sfi.pdf) 建立内存安全防护罩避免最严重的漏洞。这会带来一些运行开销，虽然[自带证明代码](https://en.wikipedia.org/wiki/Proof-carrying_code)能够减轻这部分开销。这种技术没能给类型和并发安全提供什么好处。

另一方面，基于语言的安全性，是归纳地通过类型系统规则以及局部检测（相对于全局），保证某些操作不会发生，再加上可选的运行时检查（像在缺失更强的[依赖类型系统 (dependent type system) ](https://en.wikipedia.org/wiki/Dependent_type)中的数组边界检测）。这种方法的好处在于排除安全漏洞通常更有效，因为开发者在写代码的时候就能找到问题，而不是等到程序运行的时候。但如果你能欺骗类型系统允许执行非法的操作，你就完蛋了，因为就没有防备黑客突破内存安全性的防护罩了，他可以执行任何代码。

为了利用它们其中最好的部分，多种技术经常相互结合使用，称之为深度防护。

保证安全性的运行时方面的方法包括 [Google 的 C++ sanitizers](https://github.com/google/sanitizers) 和 [微软的 "/guard" 特性](http://blogs.msdn.com/b/vcblog/archive/2014/12/08/visual-studio-2015-preview-work-in-progress-security-feature.aspx)。语言方面的方法包括 C#、Java、绝大多数函数式语言、Go 等等。但我们已经发现一些攻击，因为 C# 有 unsafe 关键字允许违反安全性的 unsafe 区域。

那么，现在你要开发一个操作系统，主要任务是要控制硬件资源、缓冲区、服务和应用程序并行运行，诸如此类，所有的的这些都是该死的不安全 (unsafe) 的东西，你该怎样用安全的语言来搞定呢？好问题！

答案出乎意料的简单：分层。

系统里面当然有一些不安全的代码。每一个不安全的组件负责封装它们不安全的部分。说得容易做起来难，要搞对这些是系统里面最难的部分。这就是为什么我们要尽可能保持这个所谓的 [可信计算基](https://en.wikipedia.org/wiki/Trusted_computing_base) (TCB) 越小越好。在操作系统核心和运行时里没有东西使用不安全的代码，只有微内核里非常少的部分有使用它。是的，我们的操作系统调度器和内存管理器都是用安全代码编写的。所有的应用级程序和库都是 100% 的安全代码，就像我们整个 Web 浏览器一样。

依赖类型安全性的一个有趣的方面是[你的编译器](https://en.wikipedia.org/wiki/Bartok_(compiler))变成了你可信计算基 (TCB) 的一部分。虽然我们的编译器使用安全语言写的，但它生成供处理器执行的指令。这风险可以通过类似自带证明代码和[类型化汇编语言 (TAL)](https://en.wikipedia.org/wiki/Typed_assembly_language) 稍微补救一下。再加上运行时检查，如软件故障隔离等，也能减轻这种风险。

我们方法的一个成果就是系统是建立在它自身之上的。这是我们推到极限的一个关键原则。关于这个，我[之前提到过](http://joeduffyblog.com/2014/09/10/software-leadership-7-codevelopment-is-a-powerful-thing/)一点儿。但当你的操作系统核心、文件系统、网络栈、设备驱动、UI 和图形栈，Web 浏览器、Web 服务器、多媒体栈、...、甚至编译器自己都是用你的安全编程模型写的，你当然会确信它能够搞定你扔给它的任何东西。

你可能想知道所有这些安全性的开销。简而言之，没有指针运算、数据争用这种操作，是有些事情你做不到的。我们做了很多以最小化额外的开销。而我可以很高兴的说，最后，我们的确完成了一个有竞争力的系统。在系统自己之上建立系统是让我们保持诚实的关键。事实证明，像非阻塞式 IO、轻量级进程、细粒度并发、异步消息分发、还有更多类似的架构决定带来的好处，远远超过整个软件栈上下都实行安全带来的“次要的”开销。

举例来说，我们真有些类型只是些数据位堆。但这些只是些[被动数据结构 (PODs)](https://en.wikipedia.org/wiki/Passive_data_structure)。这使我们能够在字节缓冲区中解析数据位 —— 而且能够在完全不同的“类型”中互相转换 —— 高效而且没有损失安全性。我们有一个头等的切片类型，允许我们在缓冲区上构造安全的、检查的 (checked) 窗口，统一了我们所有访问系统中内存的方法。（我们加到 .NET 中的这个[切片类型](https://github.com/joeduffy/slice.net)就是受它启发的。）

你可能也想知道支持类型安全的[运行时类型信息 (RTTI) ](https://en.wikipedia.org/wiki/Run-time_type_information)的开销。感谢 PODs 和对[变体类型 (discriminated unions)](https://en.wikipedia.org/wiki/Tagged_union) 适当的支持，我们不需要经常转换类型。而且当我们需要做转换的时候，编译器能帮忙优化处理结构地狱。结果就是不会比典型的支持虚拟分发的 C++ 程序开销大多少 (不要理转换)。
