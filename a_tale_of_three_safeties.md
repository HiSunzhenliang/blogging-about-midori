# 三种安全

Midori 是在三种安全性的基础上建立的：类型、内存以及并发安全性。这些安全性排除了一整类的“建造” bug，而且在可靠性、安全性、开发人员生产力方面带来了巨大的提升。而且它们从基础上允许我们用一种新的更强有力的方式去依赖类型系统，去带来新的抽象，去完成新奇的编译器优化，还有更多。再回过头看，我们项目最大的贡献是证明了，整个操作系统和它的系统服务、应用和类库生态系统能全都用安全代码写出来，而且没有性能损失，在若干重要的维度还有一些数量级的领先。

首先，让我们定义这三种安全性，根据基础性来排序：

* [内存安全](https://en.wikipedia.org/wiki/Memory_safety) 阻止访问内存的非法区域。若违反内存安全，将出现多种缺陷，包括缓冲区溢出，释放 (free) 后使用内存，以及重复释放内存。总体来说，违反内存安全性是一种很严重的问题，会导致很多漏洞，譬如代码注入等。

* [类型安全](https://en.wikipedia.org/wiki/Type_safety) 阻止使用分配给别的类型的内存。若违反类型安全，将出现多种缺陷，包括类型混淆，转换错误，以及未初始化的变量。虽然通常没有违反内存安全那么严重，但违反类型安全性仍然会导致漏洞，特别是可能引发内存安全漏洞。

* [并发安全](https://en.wikipedia.org/wiki/Thread_safety) 阻止不安全的并发使用共享内存。此类众所周知并发危害包括[数据冲突](https://en.wikipedia.org/wiki/Race_condition)，或读写、写读、写写危险。通常，如果违反了并发安全，会频繁导致类型、进一步导致内存安全性被违反。这种问题比较微妙 —— 像内存被撕裂一样 —— 我们经常说，并发漏洞是安全漏洞利用的“下一个前沿”。

目前已经存在很多方法来确保一项或多项以上安全，并/或保护目标免于危害。

[软件故障隔离](http://www.cs.cmu.edu/~srini/15-829/readings/sfi.pdf) 建立内存安全防护罩避免最严重的漏洞。这会带来一些运行开销，虽然[自带证明代码](https://en.wikipedia.org/wiki/Proof-carrying_code)能够减轻这部分开销。这种技术没能给类型和并发安全提供什么好处。

另一方面，基于语言的安全性，是归纳地通过类型系统规则以及局部检测（相对于全局），保证某些操作不会发生，再加上可选的运行时检查（像在缺失更强的[依赖类型系统 (dependent type system) ](https://en.wikipedia.org/wiki/Dependent_type)中的数组边界检测）。这种方法的好处在于排除安全漏洞通常更有效，因为开发者在写代码的时候就能找到问题，而不是等到程序运行的时候。但如果你能欺骗类型系统允许执行非法的操作，你就完蛋了，因为就没有防备黑客突破内存安全性的防护罩了，他可以执行任何代码。

为了利用它们其中最好的部分，多种技术经常相互结合使用，称之为深度防护。

保证安全性的运行时方面的方法包括 [Google 的 C++ sanitizers](https://github.com/google/sanitizers) 和 [微软的 "/guard" 特性](http://blogs.msdn.com/b/vcblog/archive/2014/12/08/visual-studio-2015-preview-work-in-progress-security-feature.aspx)。语言方面的方法包括 C#、Java、绝大多数函数式语言、Go 等等。但我们已经发现一些攻击，因为 C# 有 unsafe 关键字允许违反安全性的 unsafe 区域。

那么，现在你要开发一个操作系统，主要任务是要控制硬件资源、缓冲区、服务和应用程序并行运行，诸如此类，所有的的这些都是该死的不安全 (unsafe) 的东西，你该怎样用安全的语言来搞定呢？好问题！

答案出乎意料的简单：分层。

系统里面当然有一些不安全的代码。每一个不安全的组件负责封装它们不安全的部分。说得容易做起来难，要搞对这些是系统里面最难的部分。这就是为什么我们要尽可能保持这个所谓的 [可信计算基](https://en.wikipedia.org/wiki/Trusted_computing_base) (TCB) 越小越好。在操作系统核心和运行时里没有东西使用不安全的代码，只有微内核里非常少的部分有使用它。是的，我们的操作系统调度器和内存管理器都是用安全代码编写的。所有的应用级程序和库都是 100% 的安全代码，就像我们整个 Web 浏览器一样。

依赖类型安全的一个有趣的方面是[你的编译器](https://en.wikipedia.org/wiki/Bartok_(compiler))变成了你可信计算基 (TCB) 的一部分。虽然我们的编译器使用安全语言写的，但它生成供处理器执行的指令。这风险可以通过类似自带证明代码和[类型化汇编语言 (TAL)](https://en.wikipedia.org/wiki/Typed_assembly_language) 稍微补救一下。再加上运行时检查，如软件故障隔离等，也能减轻这种风险。

我们方法的一个成果就是系统是自举的。这是我们推到极限的一个关键原则。关于这个，我[之前提到过](http://joeduffyblog.com/2014/09/10/software-leadership-7-codevelopment-is-a-powerful-thing/)一点儿。但当你的操作系统核心、文件系统、网络栈、设备驱动、UI 和图形栈，Web 浏览器、Web 服务器、多媒体栈、...、甚至编译器自己都是用你的安全编程模型写的，你当然会确信它能够搞定你扔给它的任何东西。

你可能想知道所有这些安全的开销。简而言之，没有指针运算、数据争用这种操作，是有些事情你做不到的。我们做了很多以最小化额外的开销。而我可以很高兴的说，最后，我们的确完成了一个有竞争力的系统。在系统自己之上建立系统是让我们保持诚实的关键。事实证明，像非阻塞式 IO、轻量级进程、细粒度并发、异步消息分发、还有更多类似的架构决定带来的好处，远远超过整个软件栈上下都实行安全带来的“次要的”开销。

举例来说，我们真有些类型只是些数据位堆。但这些只是些[被动数据结构 (PODs)](https://en.wikipedia.org/wiki/Passive_data_structure)。这使我们能够在字节缓冲区中解析数据位 —— 而且能够在完全不同的“类型”中互相转换 —— 高效而且没有损失安全性。我们有一个头等的切片类型，允许我们在缓冲区上构造安全的、检查的 (checked) 窗口，统一了我们所有访问系统中内存的方法。（我们加到 .NET 中的这个[切片类型](https://github.com/joeduffy/slice.net)就是受它启发的。）

你可能也想知道支持类型安全的[运行时类型信息 (RTTI) ](https://en.wikipedia.org/wiki/Run-time_type_information)的开销。感谢 PODs 和对[变体类型 (discriminated unions)](https://en.wikipedia.org/wiki/Tagged_union) 适当的支持，我们不需要经常转换类型。而且当我们需要做转换的时候，编译器能帮忙优化处理结构地狱。结果就是不会比典型的支持虚拟分发的 C++ 程序开销大多少 (别管转换)。

通过这次旅程，常常可以发现编译器技术在过去的 20 年里有了惊人的进步。大部分情况下，安全开销能得到非常有力的优化。不是说这些开销能降到零，但我们可以认为它们只是大部分有趣的程序的小噪音。而且令人惊奇的是，我们发现大量情况下安全性带来新的特别的优化技术！例如，通过在类型系统中使用不可变性，允许我们在多个堆和程序中更加激进地共享内存页；教编译器[约定](https://en.wikipedia.org/wiki/Design_by_contract)知识让我们更积极地提升类型安全检查，等等。

另一个有争议的领域是并发安全。特别是这个项目开始的日子跟 2000 年代后期令人兴奋的多核时代有重叠。什么？没有并行性？你会这样问。

注意我可没说过我们禁止所有的并发，我们只是禁止不安全的并发。首先，大部分的系统内的并发表现为在轻量级的[软隔离进程](http://research.microsoft.com/apps/pubs/default.aspx?id=71996)间使用消息传递。其次，对于同一个进程的并发，我们形式化了安全共享内存并行的规则，通过类型系统和编程模型规则来确保这点。结果就是你不会写出共享内存的数据争用。

引致这种形式化的一个关键的洞悉是没有两个共享同一个地址空间的“线程”被允许同时看到可修改的同一个对象。多个线程可以同时读同一块内存，一个线程可以写，但不能多个线程同时写。一些细节在[我们的 OOPSLA 论文（安全并行中的唯一性和引用不变性）](http://research.microsoft.com/apps/pubs/default.aspx?id=170528)中有讨论，还有 Rust 也完成了类似的成果[并文档化得很好](http://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html)。对多数细粒度的并行来说，这种规则工作得足够好了，就像我们的多媒体栈一样。

Midori 之后，我一直致力于将怎样同时实现安全和高效 (performance) 的经验带到 .NET 和 C++ 中。可能目前可见的成果只有我们近段时间作为 C++ 核心指引的一部分发布的[安全 profiles](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-profile)。我希望在 C# 7 中和我们正在搞的 .NET 跨平台 C# AOT 中，有更多的成果出现。Midori 是一块处女地，而当前的这些环境需要微妙的折中和妥协，是充满乐趣，但减慢了将这些点子转化为产品的速度。我很高兴开始见到终于结出了一些果实。

内存、类型和并发安全的组合给了我们一个有力的基础。最重要的是，它带给开发人员更高水平的生产力，让我们能够更快前进。最麻烦的缓冲区溢出、数据争用、死锁之类的玩意，就简单的从不会出现。总有一天，所有的操作系统都会这样写。

在这系列的下一篇文章中，我们将会看看这些安全性基础如何让我们带来作为编程模型和类型系统头等公民的[基于能力的安全模型](https://en.wikipedia.org/wiki/Capability-based_security)，并带来同样“手工打造”的解决方案，以避免 [ambient authority](https://en.wikipedia.org/wiki/Ambient_authority)，默认情况下，启用无处不在的[最小权限原则](https://en.wikipedia.org/wiki/Principle_of_least_privilege)。回见。  




> 原文：[A Tale of Three Safeties](http://joeduffyblog.com/2015/11/03/a-tale-of-three-safeties/)