# 错误模型

[Midori](https://github.com/ZiJing6/blogging-about-midori) 是用 [AOT 编译的，基于 C# 的类型安全语言](https://github.com/ZiJing6/blogging-about-midori/blob/master/safe_native_code.md)写的。除了我们的微内核，整个系统都是用它写的，包括驱动，域核心以及所有的用户代码。之前我已经提示了一些东西，现在是时候直面它们了。整个语言覆盖非常丰富的地方，需要用上一系列的文章。从哪里开始？错误模型。传播和处理错误的方式对任何语言来说都是至关重要的，特别是用于编写可靠的操作系统的语言。像我们在 Midori 做的其他事情一样，一个“整个系统”的方法是必须的，以保证它的正确，花了好几年来进行了好几次迭代。我经常听到团队成员说，这是他们在 Midori 编程方面最想念的事情。对我来说也是如此。所以，不用多说，我们开始吧。

## 介绍

错误模型要回答的基本问题是：“错误”是如何传递给程序员和系统用户的？很简单？那只是看着像。

回答这个问题的最大挑战之一是定义错误到底_是_什么。大多数语言将 bug 和可以恢复的错误归到同一类，并使用相同的措施去处理它们。对 null 引用和数组越界访问，跟网络连接问题或者解析错误同样对待。这种一致性咋一看很不错，但它有根深蒂固的问题。特别是，这具有误导性，经常导致不可靠的代码。

我们的整体解决方案是提供一种双管齐下的错误模型。一方面，你有 fail-fast —— 我们称它为_丢弃（abandonment）_ —— 对于程序 bug。另一方面，对于可恢复的错误，你有静态 checked 异常。这两种是非常不同的，在于编程模型也在他们背后的机制。丢弃瞬间销毁整个进程，并拒绝执行任何用户代码。（要记得，Midori 的典型程序有很多小的轻量级的进程。）异常，当然，可以被恢复，但需要深入的类型系统支持来帮助检查和验证。

这段旅程是漫长曲折的。我会把这个故事分为六块：

* 雄心和教训
* Bug 不是可恢复的错误！
* 可靠性，容错性和隔离
* Bugs：丢弃、断言和契约
* 可恢复的错误：类型定向的（Type-Directed）异常
* 回顾和结论

事后看来，某些结果似乎很明显。特别现在有了现代的系统语言像 Go 和 Rust。但有些结果让我们感到惊讶。我会尽可能切题，但在介绍过程中，我同时给出足够的背景故事。我们尝试了很多无法工作的东西，我认为这比在尘埃落定时我们得到的结果更有趣。

## 雄心和教训

