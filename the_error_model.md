# 错误模型

[Midori](https://github.com/ZiJing6/blogging-about-midori) 是用 [AOT 编译的，基于 C# 的类型安全语言](https://github.com/ZiJing6/blogging-about-midori/blob/master/safe_native_code.md)写的。除了我们的微内核，整个系统都是用它写的，包括驱动，域核心以及所有的用户代码。之前我已经提示了一些东西，现在是时候直面它们了。整个语言覆盖非常丰富的地方，需要用上一系列的文章。从哪里开始？错误模型。传播和处理错误的方式对任何语言来说都是至关重要的，特别是用于编写可靠的操作系统的语言。像我们在 Midori 做的其他事情一样，一个“整个系统”的方法是必须的，以保证它的正确，花了好几年来进行了好几次迭代。我经常听到团队成员说，这是他们在 Midori 编程方面最想念的事情。对我来说也是如此。所以，不用多说，我们开始吧。

## 介绍

错误模型要回答的基本问题是：“错误”是如何传递给程序员和系统用户的？很简单？那只是看着像。

回答这个问题的最大挑战之一是定义错误到底*是*什么。大多数语言将 bug 和可以恢复的错误归到同一类，并使用相同的措施去处理它们。对 null 引用和数组越界访问，跟网络连接问题或者解析错误同样对待。这种一致性咋一看很不错，但它有根深蒂固的问题。特别是，这具有误导性，经常导致不可靠的代码。

我们的整体解决方案是提供一种双管齐下的错误模型。一方面，你有 fail-fast —— 我们称它为*丢弃（abandonment）* —— 对于程序 bug。另一方面，对于可恢复的错误，你有静态 checked 异常。这两种是非常不同的，在于编程模型也在他们背后的机制。丢弃瞬间销毁整个进程，并拒绝执行任何用户代码。（要记得，Midori 的典型程序有很多小的轻量级的进程。）异常，当然，可以被恢复，但需要深入的类型系统支持来帮助检查和验证。

这段旅程是漫长曲折的。我会把这个故事分为六块：

* 雄心和教训
* Bug 不是可恢复的错误！
* 可靠性，容错性和隔离
* Bugs：丢弃、断言和契约
* 可恢复的错误：类型定向的（Type-Directed）异常
* 回顾和结论

事后看来，某些结果似乎很明显。特别现在有了现代的系统语言像 Go 和 Rust。但有些结果让我们感到惊讶。我会尽可能切题，但在介绍过程中，我同时给出足够的背景故事。我们尝试了很多无法工作的东西，我认为这比在尘埃落定时我们得到的结果更有趣。

## 雄心和教训

让我们从检查我们的架构原则、需求以及从已存在的系统学到的东西开始。

### 原则

在我们着手这段旅程时，我们提出了一个很好的错误模型需要满足的几个需求：

* **可用性（Usable）**。面对错误，开发人员一定要很容易做出“正确”的事情，就好像不经意的一样。一个著名的同事和朋友称之为[成功之坑](https://blogs.msdn.microsoft.com/brada/2003/10/02/the-pit-of-success/)。该模式不应该给编写常见的代码强加过多的拘束。理想情况下，它是我们目标受众认知上熟悉的。

* **可靠性（Reliable）**。错误模型是整个系统可靠性的基础。毕竟我们正在建造一个操作系统，所以可靠性是最重要的。你甚至可能职责我们痴迷于追求极端的可靠性。我们指导大多数编程模型开发的真言是“*通过构建获得正确性*”。

* **高性能（Performant）**。通常的情况需要极致的快。这意味着成功路径的开销尽可能接近零。任何失败路径上的开销必须是“pay-for-play”的。不像很多现代系统会过多惩罚错误路径，我们有几个性能关键的组件，这样是不可接受的，所以错误也必须相当的快。

* **并发（Concurrent）**。我们的整个系统是分布式而且高并发的。这关注点通常在其他错误模型的考量点是比较靠后，而在我们系统中是必须靠前而且是中心的。

* **可诊断性（Diagnosable）**。调试错误，无论在交互中还是事后，都需要高效而且容易。

* **可组合（Composable）**。本质上，错误模型是编程语言的一个特性，是开发人员用表达代码的核心。因此，它应当提供与系统的其他特性的正交性和可组合性。集成分别编写的组件必须是自然的，可靠的和可预测的。

这是一个大胆的宣称，然而我的确认为我们在所有的维度都取得了成功。

### 经验教训

现有的错误模型不满足以上需求，至少不完全满足。若其中一个在一个维度做得好，在另一个维度就做得差。举个例子，错误码有很好的可靠性，但很多程序员发现他们很容易误用；更差的是，它很容易就做了错事 —— 像忘记检查它 —— 这当然违反了“成功之坑”的需求。

鉴于我们寻求的可靠性的极限程度，我们对大多数模型不满意也就没什么好奇怪的了。

如果你正在优化易用性相对于可靠性，就像在脚本语言中一样，你的结论会有显著的不同。像 Java 和 C# 努力竞争是因为它们就正好在各种场景十字路口中间 —— 有时候被用来做系统开发，有时候被用来做应用开发 —— 但总的上它们的错误模型非常不适合我们的需求。

最后还要提一下，这个故事开始于 2000 年代中期，在 Go、Rust 和 Swift 可供我们参考之前。这三种语言从那之后在错误模型方面做一些很不错的工作。

#### 错误码

错误码可以说是最简单的错误模型。想法是非常基本的，甚至不需要语言或运行时的支持。函数只是返回一个值，通常是一个整数，表示成功或者失败。

```csharp
int foo() {
    // <try something here>
    if (failed) {
        return 1;
    }
    return 0;
}
```

这就是典型的模式，返回一个 0 表示成功，非 0 表示失败。调用者必须检查它：

```csharp
int err = foo();
if (err) {
    // Error!  Deal with it.
}
```

大多数系统提供错误码的常量集合，而不是 magic number。可能有也可能没有一个函数你可以用来获得关于最近一个错误的额外信息（像标准 C 里的 errno 和 Win32 的 GetLastError）。一个返回码真的不是语言里什么特别的东西 —— 它只是一个返回值。

C 长期使用错误码，因此，大多数基于 C 的生态系统都这样做。更多低层的系统代码已经写成了使用返回码的规则而不是其他。Linux 是这样，其他的无数的关键任务和实时系统也是这样。所以，可以很公平地说它们有一个令人印象深刻的记录。

在 Windows 上，HRESULT 是一样的。一个 HRESULT 只是一个整数的“handle”，而且在 winerror.h 中有一大串的常量和宏，例如 S_OK，E_Fault，和用来生成和检查值的SUCCEEDED()。Windows 里最重要的代码是用返回码的规则写出来的。在内核中找不到异常。至少也不是故意地使用异常。

在手动管理内存的环境中，在出现错误时释放内存是非常困难的。返回码可以让这点好受点。C++ 使用 [RAII](https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization) 有更多的自动化方法来处理这个，但除非你坚决贯彻 C++ 模型 —— 很多系统程序员都不会这么做 —— 那么没有很好的办法可以在 C 程序中增量使用 RAII。

最近，Go 选择了错误码。虽然 Go 的方法类似 C 的，它通过好得多的语法和库变得更加现代化。

许多函数式语言通过伪装成 monad 的方式使用返回码，称之为 Option&lt;T>、Maybe&lt;T> 或 Error&lt;T>，这些与数据流风格的编程及模式匹配一起使用时，感觉更加自然。这种方法消除了返回码的一些主要缺点，尤其是与 C 相比，我们将在下文继续讨论。Rust 很大程度上采用了这个模型，但对系统程序员来说还有一些令人兴奋的东西。

尽管它们非常简单，返回码的确也有些包袱；总结如下：

* 性能会受到影响
* 编程模型可用性会变差
* 最重要的是：你会意外地忘记检查错误。

让我们讨论每一个，按照顺序来，并基于上述的语言提供一些例子。

##### 性能

错误码在通常情况下“零开销”，只为不通常的情况付出代价的测试中落败。

1. 存在调用协定的影响。你现在有了*两个*值需要返回（对于不是返回 void 的函数）：实际的返回值和可能的错误。这烧掉了更多的寄存器和/或栈空间，使调用效率更低。对于可以内联的调用子集来说，内联对改善这个有帮助。
2. 在被调用者有可能失败的地方在 callsite 中都有分支注入。我称类似这种的开销为“花生酱”，因为那些检查在代码中抹得到处都是，使得很难测量直接的影响。在 Midori 中，我们能够做实验并测量，并可以确认，这种成本是不可忽视的。还有一个次要的影响，因为函数包含了多个分支，有更多的扰乱优化器的风险。

这可能令某些人觉得惊奇，因为无疑每个人都听说过“异常很慢”。事实证明，它们不是一定会这样。并且，如果能做对的话，它们让错误处理代码和数据从热路径（hot path）中移出去，这增加了 I-cache 和 TLB 的性能，对比上述的开销，那显然减慢了它们。

许多高性能系统已经使用返回码来构建，所以你可能会认为我很挑剔。正如我们做的很多事情一样，一个简单的批评是我们做的方法太极端了。但包袱会更差。

##### 忘记检查它们

很容易就忘记检查一个返回码。例如，考虑一个函数：

```csharp
int foo() { ... }
```

现在在调用点，要是我们静静地忽略了返回值，就这样继续，会发生什么呢？

```csharp
foo();
// Keep going -- but foo might have failed!
```

在这里，你已经在程序中掩盖了潜在的关键错误。这是使用错误码很容易出现的最棘手有害的问题。选项类型（option type）能帮助函数式语言解决这个问题。但对于基于 C 的语言，甚至对于使用现代语法的 Go，这是真正的问题。

这问题不只是理论上可能存在。我遇到过无数由于忽略返回码造成的错误，我敢肯定你也遇到过。事实上，正在开发这个错误模型时，我的团队遇到了些让人困惑的错误。例如，当我们将微软的语音服务移植到 Midori 时，我们发现 80% 的繁体中文（zh-tw）请求失败了。不是以一种开发人员立刻能看到的方式失败，而是，客户端会得到一个乱码响应。一开始，我们以为是我们的错，但然后我们发现了原始代码中的一处默默地吞下了 HRESULT。当我们将它挪到 Midori，bug 就被扔到了我们脸上，被找出来并立刻被改好。这段经历当然肯定了我们对于错误码的看法。

令我惊奇的是 Go 将没使用的 import 作为一个错误，却忽视了这个远远更重要的问题。太可惜了！

你的确可以加入一个静态分析检查器，或者也许一个“未使用的返回值”警告，就像大多数商用的 C++ 编译器一样。但一旦你错过将它作为需求加入到语言核心的机会，所有的这些技术没有一个能触及关键的东西，因为对有噪音的分析的抱怨。

无论如何，在我们的语言中，忘记使用返回值是一个编译时错误。你必须要显式忽略它们；一开始我们使用一个 API 来这样做，但最终设计了一个语言语法 —— 跟 >/dev/null 这些一样：

```csharp
ignore foo();
```

我们没有使用错误码，然而必须处理返回值的能力对系统的整体可靠性是至关重要的。有多少次你调试系统时会发现，问题的根本原因在于你忘记了使用一个返回值？甚至一些安全漏洞是因为这样造成的。让开发人员显式标记“忽略”返回值也没办法完全避免问题，毕竟他们还是可以做其他错事，但至少它是显式的和可审计的。

##### 编程模型可用性

在用错误码的基于 C 的语言中，你最终不得不在每个调用之后手写很多 if 检查。如果有很多函数可能失败，这就会非常乏味，在 C 程序中，分配失败也是用的返回码，所以可能频繁会失败。返回多个值也是很笨拙的。

警告：这个抱怨是很主观的。在很多方面，返回码的可用性实际上是很优雅的。你重用非常简单的基元 —— 整数、返回和 if 分支 —— 在无数其他情况下也会使用。在我粗鄙的想法中，错误是编程中一个足够重要的概念，语言应当要对你提供帮助。

Go 有一个很好的快捷语法让标准的返回码检查*略微*更令人愉快点：

```go
if err := foo(); err != nil {
    // Deal with the error.
}
```

要注意到我们调用了 foo 并检查是否 error 是非 nil 的，在一行代码中。相当整洁。

可用性问题不止于此，然而。

通常，给定的函数中的很多错误会共享一些相同的错误恢复以及修复逻辑。很多 C 程序员使用 label 和 goto 语句来描述这种结构，例如：

```c
int error;

// ...

error = step1();
if (error) {
    goto Error;
}

// ...

error = step2();
if (error) {
    goto Error;
}

// ...

// Normal function exit.
return 0;

// ...
Error:
// Do something about `error`.
return error;
```

不用说，这样的代码只有你妈才会喜欢。

在像 D、C# 和 Java 中，你有 finally 块来更加直接地编码这种“离开范围之前”模式。类似地，微软对 C++ 的自有扩展提供了 __finally，甚至当你还没有全面进入 RAII 和异常就可以使用。而 D 提供了 scope 以及 Go 提供了 defer。所有的这些根除了 goto Error 模式。

下一步，设想我的函数想要返回一个真正的（real）值*以及*一个错误的可能性？我们已经烧制好了返回槽（return slot）所以有两种显然的可能做法：

1. 我们可以用返回槽容纳两者之一（通常是错误码），用另一个槽 —— 比如指针参数 —— 来容纳另一个值（通常是真正的值）。这是 C 语言中的常用做法。
2. 我们可以返回一个结构，结构中容纳了两者。正如我们将看到的，这在函数式语言中是很常见的。但在类似 C 的语言，或甚至在 Go 中，这些缺乏参数的多态性的语言中，你会丢失关于返回值的类型信息，所以这就很少见到了。当然，C++ 加入了 template，所以理论上它可以这样干，然而它也加入了异常，所以围绕返回码的生态系统是缺乏的。

为了支持上述的性能要求，想象一下你程序用这两种方法生成的汇编代码结果。

###### “在旁边”返回值

用 C 写第一种方法的例子如下：

```c
int foo(int* out) {
    // <try something here>
    if (failed) {
        return 1;
    }
    *out = 42;
    return 0;
}
```

真正的值不得不通过“旁边”来返回，让调用显得很笨拙：

```c
int value;
int ret = foo(&value);
if (ret) {
    // Error!  Deal with it.
}
else {
    // Use value...
}
```

不止是变得笨拙，这种模式扰乱了你编译器的[定义分配分析](https://en.wikipedia.org/wiki/Definite_assignment_analysis)，这损害了你获得像使用未初始化的值这种良好 warning 的能力。

Go 也通过更好的语法瞄上了这个问题，感谢多值返回：

```go
func foo() (int, error) {
    if failed {
        return 0, errors.New("Bad things happened")
    }
    return 42, nil
}
```

因此调用就显得清晰得多了。跟之前提到的对 error 的一行 if 检查组合起来 —— 一个微妙的变化，因为乍一看数值的返回不会在 if 范围内，但实际上会 —— 这做得更好：

```go
if value, err := foo(); err != nil {
    // Error!  Deal with it.
} else {
    // Use value ...
}
```

注意这也会帮助提醒你去检查错误。然而它也不是刀枪不入的，因为函数能返回一个错误而没有另外的其他东西，这样就跟在 C 中一样容易忘记检查它。

正如我上面提到的，有些人会在可用性这一点上反对我。尤其是 Go 的设计师，我怀疑。Go 语言使用错误代码的一个很大的吸引力在于，这是对当今世界过于复杂的语言的一个反叛。我们已经失去了太多让 C 如此优雅的东西 —— 你通常可以看着任一行 C 代码，就能猜出它翻译成的机器码是什么。我不会反对这些观点。事实上，我非常喜欢 Go 对于未检查的异常和 Java 的已检查异常的化身的模型。甚至是在我写这篇文章的时候，已经写了很多 Go 代码，我看着Go语言的简洁性，好奇着下文将介绍的我们设计的各种 try 和 require 是否走得太远了呢？我不太确定。Go 的错误模型是这个语言最关键的地方；这可能很大程度上是因为你不能像大多数语言中一样对错误敷衍过去，然而程序员们确实很享受在 Midori 中写代码。最后，很难比较 Go 和 Midori。我确信两者都可以用来写可靠的代码。

###### 在数据结构中的返回值

函数式语言通过将一个值或一个错误打包进一个数据结构解决了很多可用性的挑战。因为如果你想要在调用时用返回值做任何有用的东西，你必须要将错误和值区分开来 —— 你可能会感谢编程的数据流风格 —— 这就很容易避免忘记检查错误的致命问题。

找个现代的例子来说明的话，看看 [Scala 的 Option Type](http://danielwestheide.com/blog/2012/12/19/the-neophytes-guide-to-scala-part-5-the-option-type.html)。不幸的消息是一些语言，像那些在 ML 家族的，甚至 Scala （由于它的 JVM 血统），将这种优雅的模型和 unchecked exception 世界混合在一起。这污染了单独的数据类型方法的优雅。

Haskell 做了一些更酷的事情，并且[给人一种异常处理的幻觉，但实际上还是使用错误码和本地控制流](https://wiki.haskell.org/Exception)：

> 在 C++ 程序员中有个长久以来的争论，到底是异常还是错误返回码是正确的方式？ Niklas Wirth 认为异常是 goto 的化身，所以在他的语言中省略了它们。Haskell 通过一种老到的方式解决了这个问题：函数返回错误码，但错误码的处理不会让代码变得丑陋。

这里的技巧是支持所有熟悉的 throw 和 catch 模式，但使用 monad 而不是控制流。

虽然 [Rust 也使用错误码](https://doc.rust-lang.org/book/error-handling.html)，但它也是函数式的错误类型风格。例如，设想我们正在 Go 里写一个函数名叫 bar：我们会调用 foo，然后如果它失败了，就简单地传递错误给调用者：

```go
func bar() error {
    if value, err := foo(); err != nil {
        return err
    } else {
        // Use value ...
    }
}
```

在 Rust 中的写法不会更简洁。它可能会让 C 程序员陷入引入的繁琐的模式匹配语法中（一种真正的关注，而不是搞破坏）。然而，任一个熟悉函数式编程的程序会甚至眼皮都不会眨一下，而且这种方法当然会作为一个提醒，提醒你处理你的错误：

```rust
fn bar() -> Result<(), Error> {
    match foo() {
        Ok(value) => /* Use value ... */,
        Err(err) => return Err(err)
    }
}
```

但它还能做得更好。Rust 有一个 [try! 宏](https://doc.rust-lang.org/std/macro.try!.html)，将上面那个例子缩减为一个表达式：

```rust
fn bar() -> Result<(), Error> {
    let value = try!(foo);
    // Use value ...
}
```

这带给了我们美妙的甜点。它当然会有我之前提过的性能问题，但在所有其他的维度表现得非常好。单独地它是一个不完善的图画 —— 为此，我们需要覆盖 fail-fast（又称：放弃）—— 但就如我们将见到的一样，它远比现在任何其他广泛使用的的基于异常的模型要好。

#### 异常

异常的历史引人入胜。在探索异常的旅程中，我花费了无数个小时追溯行业的步伐。包括阅读一些源头文章 —— 比如 Goodenough 在 1975 年的经典文章[《异常处理：问题和建议》](https://www.cs.virginia.edu/~weimer/2006-615/reading/goodenough-exceptions.pdf) —— 以及查找几种语言的方法：Ada、Eiffel、Modula-2 和 3、ML、以及，[最具启发性的 CLU](http://csg.csail.mit.edu/pubs/memos/Memo-155/Memo-155-3.pdf)。许多论文在总结这个漫长而艰辛的旅程方面做得比我要好，所以我在这里不会这么做。相反，我将重点放在对于搭建一个可靠的系统，那些方法有效，哪些不行。

在我们开发错误模型时，可靠性是我们最重要的需求。如果你无法对故障进行适当的反应，你的系统从定义上不会非常可靠。操作系统通常来说需要可靠。可悲的是，最常见的模式 —— unchecked exception —— 是这个维度上你会做到最差的。

由于这些原因，大部分可靠的系统采用的是返回码，而不是异常。这让本地决定如何最好地响应错误条件成为可能。我可能说得太快了，让我们深挖一下。

#### Unchecked Exception（未检查异常）

快速回顾一下。在 unchecked exception 模型中，你 throw 和 catch 异常，而不将其作为类型系统或者函数签名的一部分。例如：

```csharp
// Foo throws an unhandled exception:
void Foo() {
    throw new Exception(...);
}

// Bar calls Foo, and handles that exception:
void Bar() {
    try {
        Foo();
    }
    catch (Exception e) {
        // Handle the error.
    }
}

// Baz also calls Foo, but does not handle that exception:
void Baz() {
    Foo(); // Let the error escape to our callers.
}
```

在这个模型里，任何一个函数调用 —— 有时候任何*语句* —— 可能会抛出一个异常，转换控制到某个不在本地的地方。转移到哪里？鬼才知道。没有标记或者类型系统神器来帮你分析。结果就是，在抛出异常时任何人都很难了解程序的状态是怎样，状态会改变，当异常在调用栈用传播 —— 在并发程序中也可能跨线程传播 —— 当它被捕获或未处理时，结果状态会改变。

当然可以试着去做。这么做需要阅读 API 文档，手动审核代码，严重依赖代码审查，以及大量的好运气。语言本身在这一点上没有为你提供任何帮助。因为失败是罕见的，所以这听起来并不完全是灾难性的。我的结论是，这就是为什么业界的很多人都认为 unchecked exception 已经“足够好了”。它们在通常的成功路径脱颖而出，并且由于大多数人不会在非系统程序中编写健壮的错误处理代码，抛出异常通常很快让你避免这种麻烦。捕获异常然后继续通常也是有效的。没有伤害，没有犯规。统计意义上讲，程序是“工作的”。

也许对脚本语言来说，统计正确性是不错的，但对操作系统的最底层，或任一个处理关键任务的应用，这不是一个合适的解决方案。我希望这个不会有什么争议。

.NET 会导致更糟糕的的情况，由于它的*异步异常*。C++ 也有所谓的“异步异常”：那些由硬件错误触发的失败，像非法访问。然而，它在 .NET 中变得非常讨厌。任一个线程几乎可以在代码中的任一点注入失败。甚至在一个赋值的 RHS 和 LHS 之间！因此，源代码中看起来是原子性的操作，实际上并不是。我在[大概 10 年前写个一篇文章讨论这点](http://joeduffyblog.com/2005/03/18/atomicity-and-asynchronous-exception-failures/)，而挑战仍然还存在，尽管风险已经降低了，因为 .NET　大体认识到线程中止是有问题的。新的 CoreCLR 甚至缺少了 AppDomain，并且新的 ASP.NET Core 1.0 栈当然不像它过去那样用线程中止。但[那些 API 仍然存在](https://github.com/dotnet/coreclr/blob/99e7f7c741a847454ab0ace1febd911378dcb464/src/mscorlib/src/System/Threading/Thread.cs#L518)。

有一个著名的对 C# 主设计师  Anders Hejlsberg 的采访，谓之 [checked exception 的麻烦](http://www.artima.com/intv/handcuffs.html)。从一个系统程序员的视角来看，其中的大部分都让你挠头。没有比这更说明 C# 是面向快速程序开发者的语句了：

> Bill Venners：但这样做的话，你不是在破坏他们的代码吗？甚至在一个没有 checked exception 的语言中。如果 foo 的一个新版本打算要抛出一种新的异常，而这需要客户端要考虑处理的。是不是当他们写代码的时候没有考虑到这种异常，代码就被破坏了？

> Anders Hejlsberg：是的，因为大多数情况下，人们不会在乎的。他们不会去处理任何一个这种异常。在他们的消息循环周围有一个兜底的异常处理器，这个处理器只是弹出一个对话框说什么出了错，然后继续。程序员通过到处都是的 try finally 来保护他们的代码，所以如果异常发生了，他们能够正确处理，但他们实际上对异常处理不感兴趣。

这让我想起了 Visual Basic 中的 On Error Resume Next，以及 Windows Form 自动捕获并吞掉应用抛出的异常，然后试图继续。在这里，我不是在指责 Anders 的观点；呃，因为 C# 被广泛欢迎，我确信这是当时环境下正确的做法。但这显然不是写操作系统代码的正确方式。

C++ 至少*试着*用它的[异常抛出规范](http://en.cppreference.com/w/cpp/language/except_spec)提供了一些比 unchecked exception 更好的东西。不幸的是，这个特性依赖动态执行，这为它带来了死亡诅咒。

如果我写一个函数 void f() throw (SomeError)，它的函数体仍然可以随意调用其他 throw SomeError 之外异常的函数。类似地，如果我通过 void f() throw() 声明 f 不会抛出异常，它仍然可能调用抛出异常的其他东西。因此，为了实现声明的约定，编译器和运行时必须确保，如果这种情况发生了，std::unexpected 要被调用来终止进程作为响应。

我不是唯一认识到这种设计是错误的人。实际上，throw 现在被废弃了。一个详细的 WG21 文档，废弃异常规范，描述了 C++ 如何走到这一步，并在它的公开声明中提到这一点：

> 异常规范在实践中已经被证明几乎没有什么价值，并且还给程序增加了可观的开销。

作者列举了废弃 throw 的三个理由。三个中的两个是动态选择的结果：运行时检查（及其相关的不透明故障模式）和运行时性能开销。第三个则是，缺乏跟泛型代码的良好组合，可以通过使用适当的类型系统来解决（当然代价比较大）。

但最坏的地方在于，依赖另一个动态强制的构造 —— [noexcept 规范器](http://en.cppreference.com/w/cpp/language/noexcept_spec) —— 对这个我认为跟问题本身一样差。

[“异常安全”](https://en.wikipedia.org/wiki/Exception_safety)是 C++ 社区中常常讨论的实践。这种方法根据如下依据进行了整齐的分类：从一个函数调用者的调度角度来说，函数对于错误、状态变迁和内存管理本意是要如何响应的。一个函数属于以下四类之一：no-throw 代表执行过程保证没有异常会出现；strong safety（强安全）代表状态变迁是原子性的，一个错误不会留下部分提交的状态或破坏的不变量；basic safety（基本安全）代表，尽管一个函数可能部分提交状态变化，不变量不会被破坏而且泄露被阻止了；以及最后 no safety（不安全）代表任何事情都可能发生。这种分类很有用，我鼓励所有人有意识并严格地处理错误行为，通过这样或其他类似方式，即使你在使用错误码。问题是，在系统中使用 unchecked exception 的话，我们无法遵循上述准则，除了一个调用小而易于审计的其他函数的叶子节点数据结构。试想一下：为了保证所有地方都遵循strong safety，你需要考虑所有函数调用抛出异常的可能性，并相应地保护周围代码。这要么意味着防守式的编程，信任其它函数的文档（未经计算机检查过的），运气很好并且只调用 noexcept 函数，要么只能听天由命。感谢 RAII，basic safety 的无泄漏更容易实现了 —— 在如今通常还要感谢智能指针 —— 但不变量的破坏还是很难预防。[异常处理：虚假的安全感](http://ptgmedia.pearsoncmg.com/images/020163371x/supplements/Exception_Handling_Article.html)一文很好地总结了这一点。

对于 C++ 来说，现实的解决方案很容易预测，而且相当直接：对于需要鲁棒的系统程序，不要使用异常。这是[嵌入式 C++](https://en.wikipedia.org/wiki/Embedded_C%2B%2B) 使用的方法，另外还有大量的实时和关键任务的 C++ 指南，包括 NASA 的喷气推进实验室的。[火星上的 C++ 肯定不会在接下来使用异常](https://www.youtube.com/watch?v=3SdSKZFoUa8)。

因此如果你可以安全地避免异常并坚持在 C++ 中使用类似 C 的返回码，你还有什么好抱怨的呢？

整个 C++ 生态系统都在使用异常。要遵守上述指南，你必须得舍弃这个语言的重要部分，而且事实上，还包括类库生态系统的重要部分。想要用标准模板库？太可惜了，它使用异常。想要用 Boost？太可惜了，它使用异常。你的分配器可能会抛出 bad_alloc。等等。这甚至导致像人们创建现有类库的消除了异常的 fork 的混乱。作为例子，Windows 内核就有它自己的不使用异常的 STL 的 fork。生态系统的这种分支既不让人愉快，要维护也不实际。

这种混乱是我们陷入了不利之境。特别是因为许多语言使用 unchecked exception。很明显，它们不适合用于编写底层的、可靠的系统代码。（我确信我这么坦白地说出这个会招来一些 C++ 敌人。）在 Midori 写了这几年代码之后，再用回使用 unchecked exception 的语言写代码让我飙泪，即使只是代码审查也是折磨。但是“谢天谢地”我们有从 Java 那里可以学习和借鉴的 checked exception ……对吧？

#### Checked Exceptions

呃，checked exception。几乎所有 Java 程序员，以及所有近距离关注过 Java 的人都喜欢殴打的布偶。在我看来这很不公平，尤其是相对于未经检查的异常带来的麻烦来说。

在 Java 中，你*大体上*可以知道一个方法会抛出什么，因为一个方法必须要这样声明：

```java
void foo() throws FooException, BarException {
    ...
}
```

现在调用方就知道了调用 foo 可能会导致抛出 FooException 或 BarException。在调用点，程序员必须做出决定：1）原样传播异常，2）捕获异常并处理它们，或者 3）用某种方式转换抛出异常的类型（可能甚至“忘记”所有的类型）。举个例子：

```java
// 1) Propagate exceptions as-is:
void bar() throws FooException, BarException {
    foo();
}

// 2) Catch and deal with them:
void bar() {
    try {
        foo();
    }
    catch (FooException e) {
        // Deal with the FooException error conditions.
    }
    catch (BarException e) {
        // Deal with the BarException error conditions.
    }
}

// 3) Transform the exception types being thrown:
void bar() throws Exception {
    foo();
}
```

这离我们能用的东西很接近了。但它也在一些地方有失败之处：

1. 异常经常跟不能恢复的 bug 联系在一起，像 null 解引用，除 0 等等。
2. 因为我们可爱的 RuntimeException 朋友，实际上你并不能完全知道可能会被抛出来的*所有东西*。因为 Java 对所有的错误条件使用异常 —— 甚至对 bug，如上所述 —— 设计者意识到人们会被所有的那些异常规范搞疯。因此他们引入了一种 unchecked 的异常。也就是说，一个方法会在未声明的时候将它抛出来，并因此调用者会没意识到地调用它。
3. 虽然签名声明了异常的类型，但在调用点没有关于什么样的调用会导致抛出异常的指示。
4. 人们讨厌它们。

最后一点很有意思，迟点在描述 Midori 采用的方法时我会回头探讨它。总而言之，人们对 Java 中 checked exception 的厌恶主要来源于或者至少被加强了其他三点。结果造成的模型好像是集合两个世界里面最糟糕的。它不会帮你写出刀枪不入的代码，而且它还很难用。最后你会写出很多乱七八糟的代码，而只获得很小的好处。而且对你的接口做版本控制简直蛋疼。正如我们很快会看到的那样，我们能做得更好。

版本控制点（versioning point）是值得思考。如果你坚持单一类型的 throw，那版本控制问题不会比错误码更差。一个函数会失败或者不会。实际上，如果你将你的 API 的版本 1 设计成没有失败模式，却想在版本 2 加入失败模式，你就完蛋了。在我看来，你本来就会完蛋。一个 API 的失败模式是它的设计和调用契约的很关键的部分。正如你不应该静悄悄不让调用者知道地改掉 API 的返回类型一样，你也不应该通过一种有语义意义的方式改变失败模式。后面会讨论这个争论点。

CLU 使用了一种有趣的方式，正如在这个由 Barbara Liskov 于 1979 年写下的 [CLU 中的异常处理](http://csg.csail.mit.edu/pubs/memos/Memo-155/Memo-155-3.pdf)论文的歪歪扭扭的扫描版所描述的那样。请注意他们把关注点放在“语言学”上；换句话说，他们想要一种人们喜欢的语言。在函数调用点检查和重新传播所有错误的需求感觉很像返回值，但编程模型有一种现在我们称之为异常的更丰富和略微陈述性的感觉。最重要的是，signals（他们为 throw 起的名字）是被检查的。如果一个预料之外的 signal 发生，也有很方便的终止程序的办法。

#### 异常的普遍问题

大多数异常系统都有一些主要的东西干得不对，不管它们是 checked 的还是 unchecked 的。

首先，抛出一个异常通常是非常昂贵的。这几乎总是由于对堆栈跟踪的收集造成的。在托管系统中，收集堆栈跟踪也需要填充元数据，以创建函数符号的字符串名称。然而，如果这个错误被捕获并被处理掉的话，在运行时你甚至不需要那些信息！诊断最好还是通过日志和诊断体系来实现，而不是通过异常系统自己。关注点是正交的。尽管如此，为了达成上面说的诊断需求，需要有些东西能够将堆栈跟踪恢复出来；永远不要低估 printf 调试和堆栈跟踪的重要性。

其次，异常会严重损害代码质量。我在我的[上一篇文章](https://github.com/ZiJing6/blogging-about-midori/blob/master/safe_native_code.md)谈到过这个问题，在 [C++ 的上下文中有对关于这个主题的很好的论文](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.116.8337&rep=rep1&type=pdf)。没有静态类型系统的信息使得很难在编译器中建立控制流，这导致了过于保守的优化器。

另一个大多数异常系统搞糟的事情是鼓励了太粗粒度的错误处理。返回码的拥趸喜欢在特定函数调用时本地处理错误。（我也是！）在异常处理系统中，在一大块代码外面包一个粗粒度的 try/catch 块实在太简单了，而没有仔细地对单个的失败做出反应。这产生了几乎肯定会出错的脆弱代码；如果不是在今天，就是在不可避免的重构之后出错。许多这样的需要有正确的语法来处理。

最后，throw 的控制流通常是不可见的。即使是在使用异常来标记方法签名的 Java 中，对代码体进行审计并精确地找出异常是从哪里出来的也是不可能的。无声的控制流跟 goto 或 setjmp/longjmp 一样糟，并使编写可靠的代码非常困难。

### 我们到了哪？

在继续之前，让我们回顾一下我们到了哪里：
![模型比较](http://joeduffyblog.com/assets/img/2016-02-07-the-error-model-1.png)  

如果我们可以得到所有的优点并扔掉所有的缺点和丑陋的地方不是会非常棒吗？

单独来看这只是会向前迈出一大步。但还不足够。这导致了我们的第一个很棒的“啊哈”时刻，塑造了将会到来的一切。对于一个重大的错误的类型，上面的方法*全部*都不太适合。

## Bug 不是可修复的错误！

我们之前做了一个关键的区分，是关于可修复的错误和 bug 的不同的：

* 一个*可修复的错误*通常是程序化数据验证的结果。一些代码已经检查了世界的状态并认为这种情况不能被处理过程接受。也许是一些正在解析的标记文本、网站的用户输入或者一次暂时的网络连接失败。在这种情况下，程序是被期望去修复的。编写这些代码的开发人员必须考虑在发生这些失败事件时要做什么处理，因为不管你代码写的多么完善，这些情况还是会出现。响应可能是将情况传达给最终用户，重试或者完全放弃操作。尽管它被称为“错误”，但它是可以*预测*的，而且经常是*计划中*的情形。

* 一个 *bug* 是一种程序员没有想到的错误。输入没有被正确地验证、逻辑写错了、或者一系列问题的出现。这些问题往往不能及时被发现；需要一段时间直到“间接的影响”被直接观察到为止，到这个时候程序的状态可能已经遭到了严重的破坏。因为开发人员没有设想过这会发生，所有的措施都是没有的。这些代码涉及到的所有数据结构现在都变成了可疑的。而且由于这些问题并不一定能及时发现，事实上，还有涉及的更多是可疑的。依赖于你使用语言的隔离保证，也许整个进程都受到了污染。

这个区别是至关重要的。令人惊讶的是，绝大多数系统没有做这样的区分，至少不是通过一种原则性的方式！正如我们上面提到的，Java、C# 以及动态语言只使用异常来处理一切，而 C 和 Go 则使用返回码。C++ 能混合使用，取决于用户，但通常是一个项目只捡起一种方式然后在项目里到处使用它。但你通常不会听说语言建议*两种*不同的错误处理技术。

鉴于 bug 本身无法自动修复，我们不会尝试去 try。所有的在运行时检测到的 bug 会导致称为*放弃*的东西，这是 Midori 团队中的术语，其他地方通常称之为“[fail-fast（快速失败）](https://en.wikipedia.org/wiki/Fail-fast)”。


每一个上述的系统都提供了类放弃的机制。C# 有 Environment.FailFast；C++ 有 std::terminate；Go 有 panic；Rust 有panic!；等等。每种都会迅雷不及掩耳地终止周围的上下文。这种上下文的范围取决于系统 —— 比如，C# 和 C++ 终止进程，Go 终止当前的 Goroutine，Rust 中止当前的线程，还有一个可选的 panic 处理器尝试去抢救一下进程。

虽然我们的确更为常规并且无处不在使用放弃，但我们当然不是第一个认识到这种模式的人。这篇 [Haskell 文章](https://wiki.haskell.org/Error_vs._Exception)就很好地表达了这个区别：

> 我参与了用 C++ 编写的库的开发。其中一个开发人员告诉我，开发人员有的喜欢异常，另外一些喜欢返回码。在我看来，喜欢返回码的朋友赢了。然而，我有个印象是，**他们搞错了点：异常和返回码具有同样表现力**，然而，不应该用来描述错误。实际上，返回码包含如 ARRAY_INDEX_OUT_OF_RANGE 的定义。但是我想知道：如果从子程序获取这个返回码，我的函数需要如何反应？它会向其程序员发送邮件吗？它可以依次将该代码返回给其调用者，但也不知道如何应对它。更糟糕的是，由于我不能对函数的实现做出假设，所以我必须认为每个子例程都可能有一个 ARRAY_INDEX_OUT_OF_RANGE。我的结论是ARRAY_INDEX_OUT_OF_RANGE 是一个（编程）错误。**它在运行时无法处理或修复，而只能由开发人员修复。因此，应该不是使用返回码，而是应该使用断言**。

放弃中的细粒度的可变共享内存范围是可疑的 —— 像协程或线程或其他什么东西 —— 除非你的系统以某种方式对潜在损害的范围作出保证。尽管如此，这些机制在我们这里使用表现得非常棒！这意味着在这些语言中使用一种放弃规范是有可能的。

然而，这种方法要在规模上取得成功需要必要的架构要素。我确信你会想：“如果每次在 C# 碰到一个解 null 引用我都将整个进程干掉的话，客户会很生气，后果很严重”；以及，同样的：“那样就一点可靠性都没有了！”可靠性，很可能，不是你想的这样子。

