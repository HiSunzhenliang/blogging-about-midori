# 错误模型

[Midori](https://github.com/ZiJing6/blogging-about-midori) 是用 [AOT 编译的，基于 C# 的类型安全语言](https://github.com/ZiJing6/blogging-about-midori/blob/master/safe_native_code.md)写的。除了我们的微内核，整个系统都是用它写的，包括驱动，域核心以及所有的用户代码。之前我已经提示了一些东西，现在是时候直面它们了。整个语言覆盖非常丰富的地方，需要用上一系列的文章。从哪里开始？错误模型。传播和处理错误的方式对任何语言来说都是至关重要的，特别是用于编写可靠的操作系统的语言。像我们在 Midori 做的其他事情一样，一个“整个系统”的方法是必须的，以保证它的正确，花了好几年来进行了好几次迭代。我经常听到团队成员说，这是他们在 Midori 编程方面最想念的事情。对我来说也是如此。所以，不用多说，我们开始吧。

## 介绍

错误模型要回答的基本问题是：“错误”是如何传递给程序员和系统用户的？很简单？那只是看着像。

回答这个问题的最大挑战之一是定义错误到底_是_什么。大多数语言将 bug 和可以恢复的错误归到同一类，并使用相同的措施去处理它们。对 null 引用和数组越界访问，跟网络连接问题或者解析错误同样对待。这种一致性咋一看很不错，但它有根深蒂固的问题。特别是，这具有误导性，经常导致不可靠的代码。

我们的整体解决方案是提供一种双管齐下的错误模型。一方面，你有 fail-fast —— 我们称它为_丢弃（abandonment）_ —— 对于程序 bug。另一方面，对于可恢复的错误，你有静态 checked 异常。这两种是非常不同的，在于编程模型也在他们背后的机制。丢弃瞬间销毁整个进程，并拒绝执行任何用户代码。（要记得，Midori 的典型程序有很多小的轻量级的进程。）异常，当然，可以被恢复，但需要深入的类型系统支持来帮助检查和验证。

这段旅程是漫长曲折的。我会把这个故事分为六块：

* 雄心和教训
* Bug 不是可恢复的错误！
* 可靠性，容错性和隔离
* Bugs：丢弃、断言和契约
* 可恢复的错误：类型定向的（Type-Directed）异常
* 回顾和结论

事后看来，某些结果似乎很明显。特别现在有了现代的系统语言像 Go 和 Rust。但有些结果让我们感到惊讶。我会尽可能切题，但在介绍过程中，我同时给出足够的背景故事。我们尝试了很多无法工作的东西，我认为这比在尘埃落定时我们得到的结果更有趣。

## 雄心和教训

让我们从检查我们的架构原则、需求以及从已存在的系统学到的东西开始。

### 原则

在我们着手这段旅程时，我们提出了一个很好的错误模型需要满足的几个需求：

* **可用性（Usable）**。面对错误，开发人员一定要很容易做出“正确”的事情，就好像不经意的一样。一个著名的同事和朋友称之为[成功之坑](https://blogs.msdn.microsoft.com/brada/2003/10/02/the-pit-of-success/)。该模式不应该给编写常见的代码强加过多的拘束。理想情况下，它是我们目标受众认知上熟悉的。

* **可靠性（Reliable）**。错误模型是整个系统可靠性的基础。毕竟我们正在建造一个操作系统，所以可靠性是最重要的。你甚至可能职责我们痴迷于追求极端的可靠性。我们指导大多数编程模型开发的真言是“_通过构建获得正确性_”。

* **高性能（Performant）**。通常的情况需要极致的快。这意味着成功路径的开销尽可能接近零。任何失败路径上的开销必须是“pay-for-play”的。不像很多现代系统会过多惩罚错误路径，我们有几个性能关键的组件，这样是不可接受的，所以错误也必须相当的快。

* **并发（Concurrent）**。我们的整个系统是分布式而且高并发的。这关注点通常在其他错误模型的考量点是比较靠后，而在我们系统中是必须靠前而且是中心的。

* **可诊断性（Diagnosable）**。调试错误，无论在交互中还是事后，都需要高效而且容易。

* **可组合（Composable）**。本质上，错误模型是编程语言的一个特性，是开发人员用表达代码的核心。因此，它应当提供与系统的其他特性的正交性和可组合性。集成分别编写的组件必须是自然的，可靠的和可预测的。

这是一个大胆的宣称，然而我的确认为我们在所有的维度都取得了成功。

### 经验教训

现有的错误模型不满足以上需求，至少不完全满足。若其中一个在一个维度做得好，在另一个维度就做得差。举个例子，错误码有很好的可靠性，但很多程序员发现他们很容易误用；更差的是，它很容易就做了错事 —— 像忘记检查它 —— 这当然违反了“成功之坑”的需求。

鉴于我们寻求的可靠性的极限程度，我们对大多数模型不满意也就没什么好奇怪的了。

如果你正在优化易用性相对于可靠性，就像在脚本语言中一样，你的结论会有显著的不同。像 Java 和 C# 努力竞争是因为它们就正好在各种场景十字路口中间 —— 有时候被用来做系统开发，有时候被用来做应用开发 —— 但总的上它们的错误模型非常不适合我们的需求。

最后还要提一下，这个故事开始于 2000 年代中期，在 Go、Rust 和 Swift 可供我们参考之前。这三种语言从那之后在错误模型方面做一些很不错的工作。

#### 错误码

错误码可以说是最简单的错误模型。想法是非常基本的，甚至不需要语言或运行时的支持。函数只是返回一个值，通常是一个整数，表示成功或者失败。

```csharp
int foo() {
    // <try something here>
    if (failed) {
        return 1;
    }
    return 0;
}
```

这就是典型的模式，返回一个 0 表示成功，非 0 表示失败。调用者必须检查它：

```csharp
int err = foo();
if (err) {
    // Error!  Deal with it.
}
```

大多数系统提供错误码的常量集合，而不是 magic number。可能有也可能没有一个函数你可以用来获得关于最近一个错误的额外信息（像标准 C 里的 errno 和 Win32 的 GetLastError）。一个返回码真的不是语言里什么特别的东西 —— 它只是一个返回值。

C 长期使用错误码，因此，大多数基于 C 的生态系统都这样做。更多低层的系统代码已经写成了使用返回码的规则而不是其他。Linux 是这样，其他的无数的关键任务和实时系统也是这样。所以，可以很公平地说它们有一个令人印象深刻的记录。

在 Windows 上，HRESULT 是一样的。一个 HRESULT 只是一个整数的“handle”，而且在 winerror.h 中有一大串的常量和宏，例如 S_OK，E_Fault，和用来生成和检查值的SUCCEEDED()。Windows 里最重要的代码是用返回码的规则写出来的。在内核中找不到异常。至少也不是故意地使用异常。

在手动管理内存的环境中，在出现错误时释放内存是非常困难的。返回码可以让这点好受点。C++ 使用 [RAII](https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization) 有更多的自动化方法来处理这个，但除非你坚决贯彻 C++ 模型 —— 很多系统程序员都不会这么做 —— 那么没有很好的办法可以在 C 程序中增量使用 RAII。

最近，Go 选择了错误码。虽然 Go 的方法类似 C 的，它通过好得多的语法和库变得更加现代化。

许多函数式语言通过伪装成 monad 的方式使用返回码，称之为 Option&lt;T>、Maybe&lt;T> 或 Error&lt;T>，这些与数据流风格的编程及模式匹配一起使用时，感觉更加自然。这种方法消除了返回码的一些主要缺点，尤其是与 C 相比，我们将在下文继续讨论。Rust 很大程度上采用了这个模型，但对系统程序员来说还有一些令人兴奋的东西。

尽管它们非常简单，返回码的确也有些包袱；总结如下：

* 性能会受到影响
* 编程模型可用性会变差
* 最重要的是：你会意外地忘记检查错误。

让我们讨论每一个，按照顺序来，并基于上述的语言提供一些例子。

