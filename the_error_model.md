# 错误模型

[Midori](https://github.com/ZiJing6/blogging-about-midori) 是用 [AOT 编译的，基于 C# 的类型安全语言](https://github.com/ZiJing6/blogging-about-midori/blob/master/safe_native_code.md)写的。除了我们的微内核，整个系统都是用它写的，包括驱动，域核心以及所有的用户代码。之前我已经提示了一些东西，现在是时候直面它们了。整个语言覆盖非常丰富的地方，需要用上一系列的文章。从哪里开始？错误模型。传播和处理错误的方式对任何语言来说都是至关重要的，特别是用于编写可靠的操作系统的语言。像我们在 Midori 做的其他事情一样，一个“整个系统”的方法是必须的，以保证它的正确，花了好几年来进行了好几次迭代。我经常听到团队成员说，这是他们在 Midori 编程方面最想念的事情。对我来说也是如此。所以，不用多说，我们开始吧。

## 介绍

错误模型要回答的基本问题是：“错误”是如何传递给程序员和系统用户的？很简单？那只是看着像。

回答这个问题的最大挑战之一是定义错误到底_是_什么。大多数语言将 bug 和可以恢复的错误归到同一类，并使用相同的措施去处理它们。对 null 引用和数组越界访问，跟网络连接问题或者解析错误同样对待。这种一致性咋一看很不错，但它有根深蒂固的问题。特别是，这具有误导性，经常导致不可靠的代码。

我们的整体解决方案是提供一种双管齐下的错误模型。一方面，你有 fail-fast —— 我们称它为_丢弃（abandonment）_ —— 对于程序 bug。另一方面，对于可恢复的错误，你有静态 checked 异常。这两种是非常不同的，在于编程模型也在他们背后的机制。丢弃瞬间销毁整个进程，并拒绝执行任何用户代码。（要记得，Midori 的典型程序有很多小的轻量级的进程。）异常，当然，可以被恢复，但需要深入的类型系统支持来帮助检查和验证。

这段旅程是漫长曲折的。我会把这个故事分为六块：

* 雄心和教训
* Bug 不是可恢复的错误！
* 可靠性，容错性和隔离
* Bugs：丢弃、断言和契约
* 可恢复的错误：类型定向的（Type-Directed）异常
* 回顾和结论

事后看来，某些结果似乎很明显。特别现在有了现代的系统语言像 Go 和 Rust。但有些结果让我们感到惊讶。我会尽可能切题，但在介绍过程中，我同时给出足够的背景故事。我们尝试了很多无法工作的东西，我认为这比在尘埃落定时我们得到的结果更有趣。

## 雄心和教训

让我们从检查我们的架构原则、需求以及从已存在的系统学到的东西开始。

### 原则

在我们着手这段旅程时，我们提出了一个很好的错误模型需要满足的几个需求：

* **可用性（Usable）**。面对错误，开发人员一定要很容易做出“正确”的事情，就好像不经意的一样。一个著名的同事和朋友称之为[成功之坑](https://blogs.msdn.microsoft.com/brada/2003/10/02/the-pit-of-success/)。该模式不应该给编写常见的代码强加过多的拘束。理想情况下，它是我们目标受众认知上熟悉的。

* **可靠性（Reliable）**。错误模型是整个系统可靠性的基础。毕竟我们正在建造一个操作系统，所以可靠性是最重要的。你甚至可能职责我们痴迷于追求极端的可靠性。我们指导大多数编程模型开发的真言是“_通过构建获得正确性_”。

* **高性能（Performant）**。通常的情况需要极致的快。这意味着成功路径的开销尽可能接近零。任何失败路径上的开销必须是“pay-for-play”的。不像很多现代系统会过多惩罚错误路径，我们有几个性能关键的组件，这样是不可接受的，所以错误也必须相当的快。

* **并发（Concurrent）**。我们的整个系统是分布式而且高并发的。这关注点通常在其他错误模型的考量点是比较靠后，而在我们系统中是必须靠前而且是中心的。

* **可诊断性（Diagnosable）**。调试错误，无论在交互中还是事后，都需要高效而且容易。

* **可组合（Composable）**。本质上，错误模型是编程语言的一个特性，是开发人员用表达代码的核心。因此，它应当提供与系统的其他特性的正交性和可组合性。集成分别编写的组件必须是自然的，可靠的和可预测的。

这是一个大胆的宣称，然而我的确认为我们在所有的维度都取得了成功。

### 经验教训

现有的错误模型不满足以上需求，至少不完全满足。若其中一个在一个维度做得好，在另一个维度就做得差。举个例子，错误码有很好的可靠性，但很多程序员发现他们很容易误用；更差的是，它很容易就做了错事 —— 像忘记检查它 —— 这当然违反了“成功之坑”的需求。

鉴于我们寻求的可靠性的极限程度，我们对大多数模型不满意也就没什么好奇怪的了。

如果你正在优化易用性相对于可靠性，就像在脚本语言中一样，你的结论会有显著的不同。像 Java 和 C# 努力竞争是因为它们就正好在各种场景十字路口中间 —— 有时候被用来做系统开发，有时候被用来做应用开发 —— 但总的上它们的错误模型非常不适合我们的需求。

最后还要提一下，这个故事开始于 2000 年代中期，在 Go、Rust 和 Swift 可供我们参考之前。这三种语言从那之后在错误模型方面做一些很不错的工作。

#### 错误码

错误码可以说是最简单的错误模型。想法是非常基本的，甚至不需要语言或运行时的支持。函数只是返回一个值，通常是一个整数，表示成功或者失败。

```csharp
int foo() {
    // <try something here>
    if (failed) {
        return 1;
    }
    return 0;
}
```

这就是典型的模式，返回一个 0 表示成功，非 0 表示失败。调用者必须检查它：

```csharp
int err = foo();
if (err) {
    // Error!  Deal with it.
}
```

大多数系统提供错误码的常量集合，而不是 magic number。可能有也可能没有一个函数你可以用来获得关于最近一个错误的额外信息（像标准 C 里的 errno 和 Win32 的 GetLastError）。一个返回码真的不是语言里什么特别的东西 —— 它只是一个返回值。

C 长期使用错误码，因此，大多数基于 C 的生态系统都这样做。更多低层的系统代码已经写成了使用返回码的规则而不是其他。Linux 是这样，其他的无数的关键任务和实时系统也是这样。所以，可以很公平地说它们有一个令人印象深刻的记录。

在 Windows 上，HRESULT 是一样的。一个 HRESULT 只是一个整数的“handle”，而且在 winerror.h 中有一大串的常量和宏，例如 S_OK，E_Fault，和用来生成和检查值的SUCCEEDED()。Windows 里最重要的代码是用返回码的规则写出来的。在内核中找不到异常。至少也不是故意地使用异常。

在手动管理内存的环境中，在出现错误时释放内存是非常困难的。返回码可以让这点好受点。C++ 使用 [RAII](https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization) 有更多的自动化方法来处理这个，但除非你坚决贯彻 C++ 模型 —— 很多系统程序员都不会这么做 —— 那么没有很好的办法可以在 C 程序中增量使用 RAII。

最近，Go 选择了错误码。虽然 Go 的方法类似 C 的，它通过好得多的语法和库变得更加现代化。

许多函数式语言通过伪装成 monad 的方式使用返回码，称之为 Option&lt;T>、Maybe&lt;T> 或 Error&lt;T>，这些与数据流风格的编程及模式匹配一起使用时，感觉更加自然。这种方法消除了返回码的一些主要缺点，尤其是与 C 相比，我们将在下文继续讨论。Rust 很大程度上采用了这个模型，但对系统程序员来说还有一些令人兴奋的东西。

尽管它们非常简单，返回码的确也有些包袱；总结如下：

* 性能会受到影响
* 编程模型可用性会变差
* 最重要的是：你会意外地忘记检查错误。

让我们讨论每一个，按照顺序来，并基于上述的语言提供一些例子。

##### 性能

错误码在通常情况下“零开销”，只为不通常的情况付出代价的测试中落败。

1. 存在调用协定的影响。你现在有了_两个_值需要返回（对于不是返回 void 的函数）：实际的返回值和可能的错误。这烧掉了更多的寄存器和/或栈空间，使调用效率更低。对于可以内联的调用子集来说，内联对改善这个有帮助。
2. 在被调用者有可能失败的地方在 callsite 中都有分支注入。我称类似这种的开销为“花生酱”，因为那些检查在代码中抹得到处都是，使得很难测量直接的影响。在 Midori 中，我们能够做实验并测量，并可以确认，这种成本是不可忽视的。还有一个次要的影响，因为函数包含了多个分支，有更多的扰乱优化器的风险。

这可能令某些人觉得惊奇，因为无疑每个人都听说过“异常很慢”。事实证明，它们不是一定会这样。并且，如果能做对的话，它们让错误处理代码和数据从热路径（hot path）中移出去，这增加了 I-cache 和 TLB 的性能，对比上述的开销，那显然减慢了它们。

许多高性能系统已经使用返回码来构建，所以你可能会认为我很挑剔。正如我们做的很多事情一样，一个简单的批评是我们做的方法太极端了。但包袱会更差。

##### 忘记检查它们

很容易就忘记检查一个返回码。例如，考虑一个函数：

```csharp
int foo() { ... }
```

现在在调用点，要是我们静静地忽略了返回值，就这样继续，会发生什么呢？

```csharp
foo();
// Keep going -- but foo might have failed!
```

在这里，你已经在程序中掩盖了潜在的关键错误。这是使用错误码很容易出现的最棘手有害的问题。选项类型（option type）能帮助函数式语言解决这个问题。但对于基于 C 的语言，甚至对于使用现代语法的 Go，这是真正的问题。

这问题不只是理论上可能存在。我遇到过无数由于忽略返回码造成的错误，我敢肯定你也遇到过。事实上，正在开发这个错误模型时，我的团队遇到了些让人困惑的错误。例如，当我们将微软的语音服务移植到 Midori 时，我们发现 80% 的繁体中文（zh-tw）请求失败了。不是以一种开发人员立刻能看到的方式失败，而是，客户端会得到一个乱码响应。一开始，我们以为是我们的错，但然后我们发现了原始代码中的一处默默地吞下了 HRESULT。当我们将它挪到 Midori，bug 就被扔到了我们脸上，被找出来并立刻被改好。这段经历当然肯定了我们对于错误码的看法。

令我惊奇的是 Go 将没使用的 import 作为一个错误，却忽视了这个远远更重要的问题。太可惜了！

你的确可以加入一个静态分析检查器，或者也许一个“未使用的返回值”警告，就像大多数商用的 C++ 编译器一样。但一旦你错过将它作为需求加入到语言核心的机会，所有的这些技术没有一个能触及关键的东西，因为对有噪音的分析的抱怨。

无论如何，在我们的语言中，忘记使用返回值是一个编译时错误。你必须要显式忽略它们；一开始我们使用一个 API 来这样做，但最终设计了一个语言语法 —— 跟 >/dev/null 这些一样：

```csharp
ignore foo();
```

我们没有使用错误码，然而必须处理返回值的能力对系统的整体可靠性是至关重要的。有多少次你调试系统时会发现，问题的根本原因在于你忘记了使用一个返回值？甚至一些安全漏洞是因为这样造成的。让开发人员显式标记“忽略”返回值也没办法完全避免问题，毕竟他们还是可以做其他错事，但至少它是显式的和可审计的。

##### 编程模型可用性

在用错误码的基于 C 的语言中，你最终不得不在每个调用之后手写很多 if 检查。如果有很多函数可能失败，这就会非常乏味，在 C 程序中，分配失败也是用的返回码，所以可能频繁会失败。返回多个值也是很笨拙的。

警告：这个抱怨是很主观的。在很多方面，返回码的可用性实际上是很优雅的。你重用非常简单的基元 —— 整数、返回和 if 分支 —— 在无数其他情况下也会使用。在我粗鄙的想法中，错误是编程中一个足够重要的概念，语言应当要对你提供帮助。

Go 有一个很好的快捷语法让标准的返回码检查_略微_更令人愉快点：

```go
if err := foo(); err != nil {
    // Deal with the error.
}
```

要注意到我们调用了 foo 并检查是否 error 是非 nil 的，在一行代码中。相当整洁。

可用性问题不止于此，然而。

通常，给定的函数中的很多错误会共享一些相同的错误恢复以及修复逻辑。很多 C 程序员使用 label 和 goto 语句来描述这种结构，例如：

```c
int error;

// ...

error = step1();
if (error) {
    goto Error;
}

// ...

error = step2();
if (error) {
    goto Error;
}

// ...

// Normal function exit.
return 0;

// ...
Error:
// Do something about `error`.
return error;
```

不用说，这样的代码只有你妈才会喜欢。

在像 D、C# 和 Java 中，你有 finally 块来更加直接地编码这种“离开范围之前”模式。类似地，微软对 C++ 的自有扩展提供了 __finally，甚至当你还没有全面进入 RAII 和异常就可以使用。而 D 提供了 scope 以及 Go 提供了 defer。所有的这些根除了 goto Error 模式。

下一步，设想我的函数想要返回一个真正的（real）值_以及_一个错误的可能性？我们已经烧制好了返回槽（return slot）所以有两种显然的可能做法：

1. 我们可以用返回槽容纳两者之一（通常是错误码），用另一个槽 —— 比如指针参数 —— 来容纳另一个值（通常是真正的值）。这是 C 语言中的常用做法。
2. 我们可以返回一个结构，结构中容纳了两者。正如我们将看到的，这在函数式语言中是很常见的。但在类似 C 的语言，或甚至在 Go 中，这些缺乏参数的多态性的语言中，你会丢失关于返回值的类型信息，所以这就很少见到了。当然，C++ 加入了 template，所以理论上它可以这样干，然而它也加入了异常，所以围绕返回码的生态系统是缺乏的。

为了支持上述的性能要求，想象一下你程序用这两种方法生成的汇编代码结果。

###### “在旁边”返回值

用 C 写第一种方法的例子如下：

```c
int foo(int* out) {
    // <try something here>
    if (failed) {
        return 1;
    }
    *out = 42;
    return 0;
}
```

真正的值不得不通过“旁边”来返回，让调用显得很笨拙：

```c
int value;
int ret = foo(&value);
if (ret) {
    // Error!  Deal with it.
}
else {
    // Use value...
}
```

不止是变得笨拙，这种模式扰乱了你编译器的[定义分配分析](https://en.wikipedia.org/wiki/Definite_assignment_analysis)，这损害了你获得像使用未初始化的值这种良好 warning 的能力。

Go 也通过更好的语法瞄上了这个问题，感谢多值返回：

```go
func foo() (int, error) {
    if failed {
        return 0, errors.New("Bad things happened")
    }
    return 42, nil
}
```

因此调用就显得清晰得多了。跟之前提到的对 error 的一行 if 检查组合起来 —— 一个微妙的变化，因为乍一看数值的返回不会在 if 范围内，但实际上会 —— 这做得更好：

```go
if value, err := foo(); err != nil {
    // Error!  Deal with it.
} else {
    // Use value ...
}
```

注意这也会帮助提醒你去检查错误。然而它也不是刀枪不入的，因为函数能返回一个错误而没有另外的其他东西，这样就跟在 C 中一样容易忘记检查它。

正如我上面提到的，有些人会在可用性这一点上反对我。尤其是 Go 的设计师，我怀疑。Go 语言使用错误代码的一个很大的吸引力在于，这是对当今世界过于复杂的语言的一个反叛。我们已经失去了太多让 C 如此优雅的东西 —— 你通常可以看着任一行 C 代码，就能猜出它翻译成的机器码是什么。我不会反对这些观点。事实上，我非常喜欢 Go 对于未检查的异常和 Java 的已检查异常的化身的模型。甚至是在我写这篇文章的时候，已经写了很多 Go 代码，我看着Go语言的简洁性，好奇着下文将介绍的我们设计的各种 try 和 require 是否走得太远了呢？我不太确定。Go 的错误模型是这个语言最关键的地方；这可能很大程度上是因为你不能像大多数语言中一样对错误敷衍过去，然而程序员们确实很享受在 Midori 中写代码。最后，很难比较 Go 和 Midori。我确信两者都可以用来写可靠的代码。

###### 在数据结构中的返回值

函数式语言通过将一个值或一个错误打包进一个数据结构解决了很多可用性的挑战。因为如果你想要在调用时用返回值做任何有用的东西，你必须要将错误和值区分开来 —— 你可能会感谢编程的数据流风格 —— 这就很容易避免忘记检查错误的致命问题。

找个现代的例子来说明的话，看看 [Scala 的 Option Type](http://danielwestheide.com/blog/2012/12/19/the-neophytes-guide-to-scala-part-5-the-option-type.html)。不幸的消息是一些语言，像那些在 ML 家族的，甚至 Scala （由于它的 JVM 血统），将这种优雅的模型和 unchecked exception 世界混合在一起。这污染了单独的数据类型方法的优雅。

Haskell 做了一些更酷的事情，并且[给人一种异常处理的幻觉，但实际上还是使用错误码和本地控制流](https://wiki.haskell.org/Exception)：

> 在 C++ 程序员中有个长久以来的争论，到底是异常还是错误返回码是正确的方式？ Niklas Wirth 认为异常是 goto 的化身，所以在他的语言中省略了它们。Haskell 通过一种老到的方式解决了这个问题：函数返回错误码，但错误码的处理不会让代码变得丑陋。

这里的技巧是支持所有熟悉的 throw 和 catch 模式，但使用 monad 而不是控制流。

虽然 [Rust 也使用错误码](https://doc.rust-lang.org/book/error-handling.html)，但它也是函数式的错误类型风格。例如，设想我们正在 Go 里写一个函数名叫 bar：我们会调用 foo，然后如果它失败了，就简单地传递错误给调用者：

```go
func bar() error {
    if value, err := foo(); err != nil {
        return err
    } else {
        // Use value ...
    }
}
```

在 Rust 中的写法不会更简洁。它可能会让 C 程序员陷入引入的繁琐的模式匹配语法中（一种真正的关注，而不是搞破坏）。然而，任一个熟悉函数式编程的程序会甚至眼皮都不会眨一下，而且这种方法当然会作为一个提醒，提醒你处理你的错误：

```rust
fn bar() -> Result<(), Error> {
    match foo() {
        Ok(value) => /* Use value ... */,
        Err(err) => return Err(err)
    }
}
```

但它还能做得更好。Rust 有一个 [try! 宏](https://doc.rust-lang.org/std/macro.try!.html)，将上面那个例子缩减为一个表达式：

```rust
fn bar() -> Result<(), Error> {
    let value = try!(foo);
    // Use value ...
}
```

这带给了我们美妙的甜点。它当然会有我之前提过的性能问题，但在所有其他的维度表现得非常好。单独地它是一个不完善的图画 —— 为此，我们需要覆盖 fail-fast（又称：放弃）—— 但就如我们将见到的一样，它远比现在任何其他广泛使用的的基于异常的模型要好。

#### 异常

异常的历史引人入胜。在探索异常的旅程中，我花费了无数个小时追溯行业的步伐。包括阅读一些源头文章 —— 比如 Goodenough 在 1975 年的经典文章[《异常处理：问题和建议》](https://www.cs.virginia.edu/~weimer/2006-615/reading/goodenough-exceptions.pdf) —— 以及查找几种语言的方法：Ada、Eiffel、Modula-2 和 3、ML、以及，[最具启发性的 CLU](http://csg.csail.mit.edu/pubs/memos/Memo-155/Memo-155-3.pdf)。许多论文在总结这个漫长而艰辛的旅程方面做得比我要好，所以我在这里不会这么做。相反，我将重点放在对于搭建一个可靠的系统，那些方法有效，哪些不行。

在我们开发错误模型时，可靠性是我们最重要的需求。如果你无法对故障进行适当的反应，你的系统从定义上不会非常可靠。操作系统通常来说需要可靠。可悲的是，最常见的模式 —— unchecked exception —— 是这个维度上你会做到最差的。

由于这些原因，大部分可靠的系统采用的是返回码，而不是异常。这让本地决定如何最好地响应错误条件成为可能。我可能说得太快了，让我们深挖一下。

#### Unchecked Exception（未检查异常）

快速回顾一下。在未检查异常模型中，你 throw 和 catch 异常，而不将其作为类型系统或者函数签名的一部分。例如：

```csharp
// Foo throws an unhandled exception:
void Foo() {
    throw new Exception(...);
}

// Bar calls Foo, and handles that exception:
void Bar() {
    try {
        Foo();
    }
    catch (Exception e) {
        // Handle the error.
    }
}

// Baz also calls Foo, but does not handle that exception:
void Baz() {
    Foo(); // Let the error escape to our callers.
}
```

在这个模型里，任何一个函数调用 —— 有时候任何_语句_ —— 可能会抛出一个异常，转换控制到某个不在本地的地方。转移到哪里？鬼才知道。没有标记或者类型系统神器来帮你分析。结果就是，在抛出异常时任何人都很难了解程序的状态是怎样，状态会改变，当异常在调用栈用传播 —— 在并发程序中也可能跨线程传播 —— 当它被捕获或未处理时，结果状态会改变。

